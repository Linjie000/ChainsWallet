// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/Tron.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Any.pbobjc.h>
#else
 #import "google/protobuf/Any.pbobjc.h"
#endif

 #import "core/Tron.pbobjc.h"
 #import "core/Discover.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - TronRoot

@implementation TronRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[GPBAnyRoot extensionRegistry]];
    [registry addExtensions:[DiscoverRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - TronRoot_FileDescriptor

static GPBFileDescriptor *TronRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum AccountType

GPBEnumDescriptor *AccountType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000AssetIssue\000Contract\000";
    static const int32_t values[] = {
        AccountType_Normal,
        AccountType_AssetIssue,
        AccountType_Contract,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\n\000\002\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccountType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccountType_Normal:
    case AccountType_AssetIssue:
    case AccountType_Contract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ReasonCode

GPBEnumDescriptor *ReasonCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Requested\000BadProtocol\000TooManyPeers\000Dupli"
        "catePeer\000IncompatibleProtocol\000NullIdenti"
        "ty\000PeerQuiting\000UnexpectedIdentity\000LocalI"
        "dentity\000PingTimeout\000UserReason\000Reset\000Syn"
        "cFail\000FetchFail\000BadTx\000BadBlock\000Forked\000Un"
        "linkable\000IncompatibleVersion\000Incompatibl"
        "eChain\000TimeOut\000ConnectFail\000Unknown\000";
    static const int32_t values[] = {
        ReasonCode_Requested,
        ReasonCode_BadProtocol,
        ReasonCode_TooManyPeers,
        ReasonCode_DuplicatePeer,
        ReasonCode_IncompatibleProtocol,
        ReasonCode_NullIdentity,
        ReasonCode_PeerQuiting,
        ReasonCode_UnexpectedIdentity,
        ReasonCode_LocalIdentity,
        ReasonCode_PingTimeout,
        ReasonCode_UserReason,
        ReasonCode_Reset,
        ReasonCode_SyncFail,
        ReasonCode_FetchFail,
        ReasonCode_BadTx,
        ReasonCode_BadBlock,
        ReasonCode_Forked,
        ReasonCode_Unlinkable,
        ReasonCode_IncompatibleVersion,
        ReasonCode_IncompatibleChain,
        ReasonCode_TimeOut,
        ReasonCode_ConnectFail,
        ReasonCode_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReasonCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReasonCode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReasonCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReasonCode_Requested:
    case ReasonCode_BadProtocol:
    case ReasonCode_TooManyPeers:
    case ReasonCode_DuplicatePeer:
    case ReasonCode_IncompatibleProtocol:
    case ReasonCode_NullIdentity:
    case ReasonCode_PeerQuiting:
    case ReasonCode_UnexpectedIdentity:
    case ReasonCode_LocalIdentity:
    case ReasonCode_PingTimeout:
    case ReasonCode_UserReason:
    case ReasonCode_Reset:
    case ReasonCode_SyncFail:
    case ReasonCode_FetchFail:
    case ReasonCode_BadTx:
    case ReasonCode_BadBlock:
    case ReasonCode_Forked:
    case ReasonCode_Unlinkable:
    case ReasonCode_IncompatibleVersion:
    case ReasonCode_IncompatibleChain:
    case ReasonCode_TimeOut:
    case ReasonCode_ConnectFail:
    case ReasonCode_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AccountId

@implementation AccountId

@dynamic name;
@dynamic address;

typedef struct AccountId__storage_ {
  uint32_t _has_storage_[1];
  NSData *name;
  NSData *address;
} AccountId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AccountId_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountId__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AccountId_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountId__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountId__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Vote

@implementation Vote

@dynamic voteAddress;
@dynamic voteCount;

typedef struct Vote__storage_ {
  uint32_t _has_storage_[1];
  NSData *voteAddress;
  int64_t voteCount;
} Vote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voteAddress",
        .dataTypeSpecific.className = NULL,
        .number = Vote_FieldNumber_VoteAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Vote__storage_, voteAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = Vote_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Vote__storage_, voteCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Vote class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vote__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account

@implementation TronAccount

@dynamic accountName;
@dynamic type;
@dynamic address;
@dynamic balance;
@dynamic votesArray, votesArray_Count;
@dynamic asset, asset_Count;
@dynamic frozenArray, frozenArray_Count;
@dynamic netUsage;
@dynamic createTime;
@dynamic latestOprationTime;
@dynamic allowance;
@dynamic latestWithdrawTime;
@dynamic code;
@dynamic isWitness;
@dynamic isCommittee;
@dynamic frozenSupplyArray, frozenSupplyArray_Count;
@dynamic assetIssuedName;
@dynamic latestAssetOperationTime, latestAssetOperationTime_Count;
@dynamic freeNetUsage;
@dynamic freeAssetNetUsage, freeAssetNetUsage_Count;
@dynamic latestConsumeTime;
@dynamic latestConsumeFreeTime;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  AccountType type;
  NSData *accountName;
  NSData *address;
  NSMutableArray *votesArray;
  GPBStringInt64Dictionary *asset;
  NSMutableArray *frozenArray;
  NSData *code;
  NSMutableArray *frozenSupplyArray;
  NSData *assetIssuedName;
  GPBStringInt64Dictionary *latestAssetOperationTime;
  GPBStringInt64Dictionary *freeAssetNetUsage;
  int64_t balance;
  int64_t netUsage;
  int64_t createTime;
  int64_t latestOprationTime;
  int64_t allowance;
  int64_t latestWithdrawTime;
  int64_t freeNetUsage;
  int64_t latestConsumeTime;
  int64_t latestConsumeFreeTime;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AccountType_EnumDescriptor,
        .number = Account_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Balance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "votesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Account_FieldNumber_VotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, votesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asset",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Asset,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, asset),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_FieldNumber_FrozenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, frozenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "netUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_NetUsage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account__storage_, netUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_CreateTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Account__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestOprationTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestOprationTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Account__storage_, latestOprationTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "allowance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Allowance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Account__storage_, allowance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestWithdrawTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestWithdrawTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Account__storage_, latestWithdrawTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Code,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Account__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "isWitness",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_IsWitness,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isCommittee",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_IsCommittee,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "frozenSupplyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_FieldNumber_FrozenSupplyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, frozenSupplyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetIssuedName",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AssetIssuedName,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Account__storage_, assetIssuedName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "latestAssetOperationTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestAssetOperationTime,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, latestAssetOperationTime),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeNetUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeNetUsage,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Account__storage_, freeNetUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeAssetNetUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeAssetNetUsage,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, freeAssetNetUsage),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestConsumeTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestConsumeTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Account__storage_, latestConsumeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestConsumeFreeTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestConsumeFreeTime,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Account__storage_, latestConsumeFreeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TronAccount class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Account_Type_RawValue(TronAccount *message) {
  GPBDescriptor *descriptor = [TronAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetAccount_Type_RawValue(TronAccount *message, int32_t value) {
  GPBDescriptor *descriptor = [TronAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Account_Frozen

@implementation Account_Frozen

@dynamic frozenBalance;
@dynamic expireTime;

typedef struct Account_Frozen__storage_ {
  uint32_t _has_storage_[1];
  int64_t frozenBalance;
  int64_t expireTime;
} Account_Frozen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "frozenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Account_Frozen_FieldNumber_FrozenBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account_Frozen__storage_, frozenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_Frozen_FieldNumber_ExpireTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account_Frozen__storage_, expireTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account_Frozen class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_Frozen__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - acuthrity

@implementation acuthrity

@dynamic hasAccount, account;
@dynamic permissionName;

typedef struct acuthrity__storage_ {
  uint32_t _has_storage_[1];
  AccountId *account;
  NSData *permissionName;
} acuthrity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountId),
        .number = acuthrity_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(acuthrity__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "permissionName",
        .dataTypeSpecific.className = NULL,
        .number = acuthrity_FieldNumber_PermissionName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(acuthrity__storage_, permissionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[acuthrity class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(acuthrity__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - permision

@implementation permision

@dynamic hasAccount, account;

typedef struct permision__storage_ {
  uint32_t _has_storage_[1];
  AccountId *account;
} permision__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountId),
        .number = permision_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(permision__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[permision class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(permision__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Witness

@implementation Witness

@dynamic address;
@dynamic voteCount;
@dynamic pubKey;
@dynamic URL;
@dynamic totalProduced;
@dynamic totalMissed;
@dynamic latestBlockNum;
@dynamic latestSlotNum;
@dynamic isJobs;

typedef struct Witness__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSData *pubKey;
  NSString *URL;
  int64_t voteCount;
  int64_t totalProduced;
  int64_t totalMissed;
  int64_t latestBlockNum;
  int64_t latestSlotNum;
} Witness__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Witness__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Witness__storage_, voteCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Witness__storage_, pubKey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Witness__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalProduced",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_TotalProduced,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Witness__storage_, totalProduced),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalMissed",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_TotalMissed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Witness__storage_, totalMissed),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_LatestBlockNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Witness__storage_, latestBlockNum),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestSlotNum",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_LatestSlotNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Witness__storage_, latestSlotNum),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isJobs",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_IsJobs,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Witness class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Witness__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\002\t\000\003\006\000\004!!!\000\005\r\000\006\013\000\007\016\000\010\r\000\t\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Votes

@implementation Votes

@dynamic address;
@dynamic oldVotesArray, oldVotesArray_Count;
@dynamic newVotesArray, newVotesArray_Count;

typedef struct Votes__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *oldVotesArray;
  NSMutableArray *newVotesArray;
} Votes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Votes_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Votes__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "oldVotesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Votes_FieldNumber_OldVotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Votes__storage_, oldVotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newVotesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Votes_FieldNumber_NewVotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Votes__storage_, newVotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Votes class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Votes__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXOutput

@implementation TXOutput

@dynamic value;
@dynamic pubKeyHash;

typedef struct TXOutput__storage_ {
  uint32_t _has_storage_[1];
  NSData *pubKeyHash;
  int64_t value;
} TXOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TXOutput_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXOutput__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKeyHash",
        .dataTypeSpecific.className = NULL,
        .number = TXOutput_FieldNumber_PubKeyHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXOutput__storage_, pubKeyHash),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXOutput class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutput__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXInput

@implementation TXInput

@dynamic hasRawData, rawData;
@dynamic signature;

typedef struct TXInput__storage_ {
  uint32_t _has_storage_[1];
  TXInput_raw *rawData;
  NSData *signature;
} TXInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(TXInput_raw),
        .number = TXInput_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXInput__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXInput__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXInput class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXInput_raw

@implementation TXInput_raw

@dynamic txId;
@dynamic vout;
@dynamic pubKey;

typedef struct TXInput_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *txId;
  NSData *pubKey;
  int64_t vout;
} TXInput_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_TxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, txId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "vout",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_Vout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, vout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, pubKey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXInput_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput_raw__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\003A\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXOutputs

@implementation TXOutputs

@dynamic outputsArray, outputsArray_Count;

typedef struct TXOutputs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *outputsArray;
} TXOutputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TXOutput),
        .number = TXOutputs_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TXOutputs__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXOutputs class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutputs__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic hasRawData, rawData;
@dynamic signatureArray, signatureArray_Count;
@dynamic retArray, retArray_Count;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  Transaction_raw *rawData;
  NSMutableArray *signatureArray;
  NSMutableArray *retArray;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_raw),
        .number = Transaction_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatureArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_SignatureArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, signatureArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "retArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Result),
        .number = Transaction_FieldNumber_RetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, retArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Contract

@implementation Transaction_Contract

@dynamic type;
@dynamic hasParameter, parameter;
@dynamic provider;
@dynamic contractName;

typedef struct Transaction_Contract__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Contract_ContractType type;
  GPBAny *parameter;
  NSData *provider;
  NSData *contractName;
} Transaction_Contract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Transaction_Contract_ContractType_EnumDescriptor,
        .number = Transaction_Contract_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "parameter",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = Transaction_Contract_FieldNumber_Parameter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, parameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_Provider,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_ContractName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, contractName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Contract class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Contract__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_Contract_Type_RawValue(Transaction_Contract *message) {
  GPBDescriptor *descriptor = [Transaction_Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Contract_Type_RawValue(Transaction_Contract *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_Contract_ContractType

GPBEnumDescriptor *Transaction_Contract_ContractType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AccountCreateContract\000TransferContract\000T"
        "ransferAssetContract\000VoteAssetContract\000V"
        "oteWitnessContract\000WitnessCreateContract"
        "\000AssetIssueContract\000DeployContract\000Witne"
        "ssUpdateContract\000ParticipateAssetIssueCo"
        "ntract\000AccountUpdateContract\000FreezeBalan"
        "ceContract\000UnfreezeBalanceContract\000Withd"
        "rawBalanceContract\000UnfreezeAssetContract"
        "\000UpdateAssetContract\000CustomContract\000";
    static const int32_t values[] = {
        Transaction_Contract_ContractType_AccountCreateContract,
        Transaction_Contract_ContractType_TransferContract,
        Transaction_Contract_ContractType_TransferAssetContract,
        Transaction_Contract_ContractType_VoteAssetContract,
        Transaction_Contract_ContractType_VoteWitnessContract,
        Transaction_Contract_ContractType_WitnessCreateContract,
        Transaction_Contract_ContractType_AssetIssueContract,
        Transaction_Contract_ContractType_DeployContract,
        Transaction_Contract_ContractType_WitnessUpdateContract,
        Transaction_Contract_ContractType_ParticipateAssetIssueContract,
        Transaction_Contract_ContractType_AccountUpdateContract,
        Transaction_Contract_ContractType_FreezeBalanceContract,
        Transaction_Contract_ContractType_UnfreezeBalanceContract,
        Transaction_Contract_ContractType_WithdrawBalanceContract,
        Transaction_Contract_ContractType_UnfreezeAssetContract,
        Transaction_Contract_ContractType_UpdateAssetContract,
        Transaction_Contract_ContractType_CustomContract,
    };
    static const char *extraTextFormatInfo = "\021\000\025\000\001\020\000\002\025\000\003\021\000\004\023\000\005\025\000\006\022\000\007\016\000\010\025\000\t\035\000\n\025\000\013\025\000\014\027\000\r\027\000\016\025\000\017\023\000\020\016\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Contract_ContractType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Contract_ContractType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Contract_ContractType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Contract_ContractType_AccountCreateContract:
    case Transaction_Contract_ContractType_TransferContract:
    case Transaction_Contract_ContractType_TransferAssetContract:
    case Transaction_Contract_ContractType_VoteAssetContract:
    case Transaction_Contract_ContractType_VoteWitnessContract:
    case Transaction_Contract_ContractType_WitnessCreateContract:
    case Transaction_Contract_ContractType_AssetIssueContract:
    case Transaction_Contract_ContractType_DeployContract:
    case Transaction_Contract_ContractType_WitnessUpdateContract:
    case Transaction_Contract_ContractType_ParticipateAssetIssueContract:
    case Transaction_Contract_ContractType_AccountUpdateContract:
    case Transaction_Contract_ContractType_FreezeBalanceContract:
    case Transaction_Contract_ContractType_UnfreezeBalanceContract:
    case Transaction_Contract_ContractType_WithdrawBalanceContract:
    case Transaction_Contract_ContractType_UnfreezeAssetContract:
    case Transaction_Contract_ContractType_UpdateAssetContract:
    case Transaction_Contract_ContractType_CustomContract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_Result

@implementation Transaction_Result

@dynamic fee;
@dynamic ret;

typedef struct Transaction_Result__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Result_code ret;
  int64_t fee;
} Transaction_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_Fee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ret",
        .dataTypeSpecific.enumDescFunc = Transaction_Result_code_EnumDescriptor,
        .number = Transaction_Result_FieldNumber_Ret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, ret),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Result class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Result__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_Result_Ret_RawValue(Transaction_Result *message) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Result_Ret_RawValue(Transaction_Result *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_Result_code

GPBEnumDescriptor *Transaction_Result_code_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Sucess\000Failed\000";
    static const int32_t values[] = {
        Transaction_Result_code_Sucess,
        Transaction_Result_code_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Result_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Result_code_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Result_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Result_code_Sucess:
    case Transaction_Result_code_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_raw

@implementation Transaction_raw

@dynamic refBlockBytes;
@dynamic refBlockNum;
@dynamic refBlockHash;
@dynamic expiration;
@dynamic authsArray, authsArray_Count;
@dynamic data_p;
@dynamic contractArray, contractArray_Count;
@dynamic scripts;
@dynamic timestamp;

typedef struct Transaction_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *refBlockBytes;
  NSData *refBlockHash;
  NSMutableArray *authsArray;
  NSData *data_p;
  NSMutableArray *contractArray;
  NSData *scripts;
  int64_t refBlockNum;
  int64_t expiration;
  int64_t timestamp;
} Transaction_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "refBlockBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "refBlockHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, expiration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "authsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(acuthrity),
        .number = Transaction_raw_FieldNumber_AuthsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, authsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Contract),
        .number = Transaction_raw_FieldNumber_ContractArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, contractArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scripts",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Scripts,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, scripts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_raw__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transactions

@implementation Transactions

@dynamic transactionsArray, transactionsArray_Count;

typedef struct Transactions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} Transactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Transactions_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transactions__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transactions class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transactions__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader

@implementation BlockHeader

@dynamic hasRawData, rawData;
@dynamic witnessSignature;

typedef struct BlockHeader__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader_raw *rawData;
  NSData *witnessSignature;
} BlockHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader_raw),
        .number = BlockHeader_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witnessSignature",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_WitnessSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, witnessSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader_raw

@implementation BlockHeader_raw

@dynamic timestamp;
@dynamic txTrieRoot;
@dynamic parentHash;
@dynamic number;
@dynamic witnessId;
@dynamic witnessAddress;

typedef struct BlockHeader_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *txTrieRoot;
  NSData *parentHash;
  NSData *witnessAddress;
  int64_t timestamp;
  int64_t number;
  int64_t witnessId;
} BlockHeader_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txTrieRoot",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_TxTrieRoot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, txTrieRoot),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parentHash",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_ParentHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, parentHash),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Number,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "witnessId",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_WitnessId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "witnessAddress",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_WitnessAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader_raw__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\n\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic transactionsArray, transactionsArray_Count;
@dynamic hasBlockHeader, blockHeader;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
  BlockHeader *blockHeader;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Block_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeader",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Block_FieldNumber_BlockHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, blockHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainInventory

@implementation ChainInventory

@dynamic idsArray, idsArray_Count;
@dynamic remainNum;

typedef struct ChainInventory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
  int64_t remainNum;
} ChainInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainInventory_BlockId),
        .number = ChainInventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainInventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remainNum",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_FieldNumber_RemainNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainInventory__storage_, remainNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainInventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainInventory_BlockId

@implementation ChainInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct ChainInventory_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} ChainInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainInventory_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory_BlockId__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockInventory

@implementation BlockInventory

@dynamic idsArray, idsArray_Count;
@dynamic type;

typedef struct BlockInventory__storage_ {
  uint32_t _has_storage_[1];
  BlockInventory_Type type;
  NSMutableArray *idsArray;
} BlockInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockInventory_BlockId),
        .number = BlockInventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockInventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BlockInventory_Type_EnumDescriptor,
        .number = BlockInventory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInventory__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BlockInventory_Type_RawValue(BlockInventory *message) {
  GPBDescriptor *descriptor = [BlockInventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBlockInventory_Type_RawValue(BlockInventory *message, int32_t value) {
  GPBDescriptor *descriptor = [BlockInventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum BlockInventory_Type

GPBEnumDescriptor *BlockInventory_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Sync\000Advtise\000Fetch\000";
    static const int32_t values[] = {
        BlockInventory_Type_Sync,
        BlockInventory_Type_Advtise,
        BlockInventory_Type_Fetch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BlockInventory_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BlockInventory_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BlockInventory_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BlockInventory_Type_Sync:
    case BlockInventory_Type_Advtise:
    case BlockInventory_Type_Fetch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockInventory_BlockId

@implementation BlockInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct BlockInventory_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} BlockInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = BlockInventory_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockInventory_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInventory_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory_BlockId__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Inventory

@implementation Inventory

@dynamic type;
@dynamic idsArray, idsArray_Count;

typedef struct Inventory__storage_ {
  uint32_t _has_storage_[1];
  Inventory_InventoryType type;
  NSMutableArray *idsArray;
} Inventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Inventory_InventoryType_EnumDescriptor,
        .number = Inventory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Inventory__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = Inventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Inventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Inventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Inventory__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Inventory_Type_RawValue(Inventory *message) {
  GPBDescriptor *descriptor = [Inventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventory_Type_RawValue(Inventory *message, int32_t value) {
  GPBDescriptor *descriptor = [Inventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Inventory_InventoryType

GPBEnumDescriptor *Inventory_InventoryType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Trx\000Block\000";
    static const int32_t values[] = {
        Inventory_InventoryType_Trx,
        Inventory_InventoryType_Block,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Inventory_InventoryType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Inventory_InventoryType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Inventory_InventoryType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Inventory_InventoryType_Trx:
    case Inventory_InventoryType_Block:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Items

@implementation Items

@dynamic type;
@dynamic blocksArray, blocksArray_Count;
@dynamic blockHeadersArray, blockHeadersArray_Count;
@dynamic transactionsArray, transactionsArray_Count;

typedef struct Items__storage_ {
  uint32_t _has_storage_[1];
  Items_ItemType type;
  NSMutableArray *blocksArray;
  NSMutableArray *blockHeadersArray;
  NSMutableArray *transactionsArray;
} Items__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Items_ItemType_EnumDescriptor,
        .number = Items_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Items__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = Items_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeadersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Items_FieldNumber_BlockHeadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, blockHeadersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Items_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Items class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Items__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Items_Type_RawValue(Items *message) {
  GPBDescriptor *descriptor = [Items descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetItems_Type_RawValue(Items *message, int32_t value) {
  GPBDescriptor *descriptor = [Items descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Items_ItemType

GPBEnumDescriptor *Items_ItemType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Err\000Trx\000Block\000Blockheader\000";
    static const int32_t values[] = {
        Items_ItemType_Err,
        Items_ItemType_Trx,
        Items_ItemType_Block,
        Items_ItemType_Blockheader,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Items_ItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Items_ItemType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Items_ItemType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Items_ItemType_Err:
    case Items_ItemType_Trx:
    case Items_ItemType_Block:
    case Items_ItemType_Blockheader:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DynamicProperties

@implementation DynamicProperties

@dynamic lastSolidityBlockNum;

typedef struct DynamicProperties__storage_ {
  uint32_t _has_storage_[1];
  int64_t lastSolidityBlockNum;
} DynamicProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastSolidityBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = DynamicProperties_FieldNumber_LastSolidityBlockNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DynamicProperties__storage_, lastSolidityBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DynamicProperties class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DynamicProperties__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectMessage

@implementation DisconnectMessage

@dynamic reason;

typedef struct DisconnectMessage__storage_ {
  uint32_t _has_storage_[1];
  ReasonCode reason;
} DisconnectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = ReasonCode_EnumDescriptor,
        .number = DisconnectMessage_FieldNumber_Reason,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectMessage__storage_, reason),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectMessage class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectMessage__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DisconnectMessage_Reason_RawValue(DisconnectMessage *message) {
  GPBDescriptor *descriptor = [DisconnectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
  return GPBGetMessageInt32Field(message, field);
}

void SetDisconnectMessage_Reason_RawValue(DisconnectMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [DisconnectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - HelloMessage

@implementation HelloMessage

@dynamic hasFrom, from;
@dynamic version;
@dynamic timestamp;
@dynamic hasGenesisBlockId, genesisBlockId;
@dynamic hasSolidBlockId, solidBlockId;
@dynamic hasHeadBlockId, headBlockId;

typedef struct HelloMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  Endpoint *from;
  HelloMessage_BlockId *genesisBlockId;
  HelloMessage_BlockId *solidBlockId;
  HelloMessage_BlockId *headBlockId;
  int64_t timestamp;
} HelloMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = GPBStringifySymbol(Endpoint),
        .number = HelloMessage_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "genesisBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_GenesisBlockId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, genesisBlockId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "solidBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_SolidBlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, solidBlockId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "headBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_HeadBlockId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, headBlockId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloMessage class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\016\000\005\014\000\006\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HelloMessage_BlockId

@implementation HelloMessage_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct HelloMessage_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} HelloMessage_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloMessage_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage_BlockId__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
